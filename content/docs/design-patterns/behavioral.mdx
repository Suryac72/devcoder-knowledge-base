---
title: Behavioral Patterns
description: Object interaction patterns
order: 2
---

import { Callout } from 'fumadocs-ui/components/callout';

<Callout type="info">
This page follows **Gang of Four (GoF)** design patterns with real-world examples.
</Callout>

Behavioral patterns focus on **communication between objects** and distribution of responsibility. They define how objects interact with each other and divide responsibilities in ways that are more flexible than direct method calls.

**When to use:** When you need to define how objects communicate, manage complex workflows, or handle state changes dynamically.

---

## 1. Observer Pattern

### ğŸ¯ Problem
You have a **Subject** (like a stock price), and multiple **Observers** (trading apps, alerts, charts) that need to be notified whenever the subject changes. If you hardcode notifications, adding new observers requires changing the subject code.

### âœ… Solution
The Observer Pattern defines a one-to-many relationship where when one object (Subject) changes state, all its observers are notified automatically.

### ğŸ”‘ Key Concepts

- **Subject/Observable**: Maintains state and notifies observers of changes
- **Observer**: Interface that observers implement
- **Concrete Observer**: Updates itself when notified
- **Push vs Pull**: Subject pushes data to observers, or observers pull data

### ğŸ’» Code Example

```typescript
// Observer interface
interface StockObserver {
    void update(double price);
}

// Subject
class StockPrice {
    private double price;
    private List<StockObserver> observers = new ArrayList<>();
    
    public void attach(StockObserver observer) {
        observers.add(observer);
    }
    
    public void detach(StockObserver observer) {
        observers.remove(observer);
    }
    
    public void setPrice(double newPrice) {
        this.price = newPrice;
        notifyObservers();
    }
    
    private void notifyObservers() {
        for (StockObserver observer : observers) {
            observer.update(price);
        }
    }
}

// Concrete observers
class TradingApp implements StockObserver {
    public void update(double price) {
        System.out.println("Trading App: Stock price is " + price);
    }
}

class PriceAlert implements StockObserver {
    public void update(double price) {
        if (price > 100) {
            System.out.println("Alert: Price exceeded $100");
        }
    }
}

// Usage
StockPrice apple = new StockPrice();
apple.attach(new TradingApp());
apple.attach(new PriceAlert());
apple.setPrice(105); // Both observers notified
```

### ğŸŒ Real-World Use Cases

- **Event handling** â€” Button clicks, mouse events in GUI frameworks
- **Model-View-Controller** â€” Model notifies views of changes
- **Social media** â€” Following someone and getting their notifications
- **Stock monitoring** â€” Price changes trigger alerts
- **Pub/Sub messaging** â€” Message brokers

### âœ… Advantages

âœ… **Loose coupling** â€” Subject and observers are independent  
âœ… **Dynamic relationships** â€” Add/remove observers at runtime  
âœ… **Broadcast communication** â€” One change notifies many  
âœ… **Easy to extend** â€” New observers don't require code changes  

### âŒ Disadvantages

âŒ **Undefined order** â€” Observers notified in unpredictable order  
âŒ **Memory leaks** â€” Must unregister observers or they remain in memory  
âŒ **Performance** â€” Many observers = many notifications  
âŒ **Difficult tracing** â€” Hard to see which observer is called  

---

## 2. Strategy Pattern

### ğŸ¯ Problem
You need **multiple ways to do the same task** (e.g., payment methods: credit card, PayPal, Bitcoin), and you want to switch between them at runtime. Using if-else chains throughout code is inflexible.

### âœ… Solution
Defines a family of algorithms, encapsulates each one, and makes them interchangeable.

### ğŸ”‘ Key Concepts

- **Strategy**: Interface for different algorithms
- **Concrete Strategy**: Specific algorithm implementation
- **Context**: Uses a strategy to execute the algorithm
- **Runtime Selection**: Choose strategy dynamically

### ğŸ’» Code Example

```typescript
// Strategy interface
interface PaymentStrategy {
    void pay(double amount);
}

// Concrete strategies
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;
    
    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }
    
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " with card " + cardNumber);
    }
}

class PayPalPayment implements PaymentStrategy {
    private String email;
    
    public PayPalPayment(String email) {
        this.email = email;
    }
    
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " via PayPal: " + email);
    }
}

// Context
class ShoppingCart {
    private PaymentStrategy paymentStrategy;
    
    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }
    
    public void checkout(double total) {
        paymentStrategy.pay(total);
    }
}

// Usage
ShoppingCart cart = new ShoppingCart();
cart.setPaymentStrategy(new CreditCardPayment("1234-5678"));
cart.checkout(99.99);

cart.setPaymentStrategy(new PayPalPayment("user@email.com"));
cart.checkout(50.00);
```

### ğŸŒ Real-World Use Cases

- **Payment methods** â€” Credit card, PayPal, Google Pay
- **Sorting algorithms** â€” QuickSort, MergeSort, BubbleSort
- **Compression strategies** â€” ZIP, RAR, GZIP
- **Route planning** â€” Shortest, fastest, scenic routes
- **Authentication** â€” OAuth, JWT, Basic Auth

### âœ… Advantages

âœ… **Eliminates if-else chains** â€” Cleaner code  
âœ… **Runtime switching** â€” Change strategy anytime  
âœ… **Easy testing** â€” Test each strategy independently  
âœ… **Open/Closed Principle** â€” Add strategies without changing context  

### âŒ Disadvantages

âŒ **Many classes** â€” One class per strategy  
âŒ **Overhead** â€” For simple cases, may be overkill  
âŒ **Strategy selection** â€” Logic must exist somewhere else  

---

## 3. State Pattern

### ğŸ¯ Problem
Your object's behavior changes drastically based on its **internal state**. You end up with massive if-else statements checking the state in every method.

```typescript
// âŒ Bad: Large if-else chains
public void process() {
    if (state == PENDING) { ... }
    else if (state == PROCESSING) { ... }
    else if (state == COMPLETED) { ... }
}
```

### âœ… Solution
Encapsulates different behaviors for different states, making the object appear to change its class.

### ğŸ’» Code Example

```typescript
// State interface
interface OrderState {
    void process(Order order);
    void ship(Order order);
}

// Concrete states
class PendingState implements OrderState {
    public void process(Order order) {
        System.out.println("Order processed");
        order.setState(new ProcessingState());
    }
    
    public void ship(Order order) {
        System.out.println("Cannot ship - order not processed yet");
    }
}

class ProcessingState implements OrderState {
    public void process(Order order) {
        System.out.println("Already processing");
    }
    
    public void ship(Order order) {
        System.out.println("Order shipped");
        order.setState(new ShippedState());
    }
}

// Context
class Order {
    private OrderState state = new PendingState();
    
    public void setState(OrderState state) {
        this.state = state;
    }
    
    public void process() {
        state.process(this);
    }
    
    public void ship() {
        state.ship(this);
    }
}

// Usage
Order order = new Order();
order.process(); // Pending -> Processing
order.ship();    // Processing -> Shipped
```

### ğŸŒ Real-World Use Cases

- **Order workflows** â€” Pending â†’ Processing â†’ Shipped â†’ Delivered
- **Document lifecycle** â€” Draft â†’ Review â†’ Published â†’ Archived
- **TCP connections** â€” Established, Listen, Closed states
- **Game characters** â€” Running, Jumping, Falling, Dead
- **Elevator states** â€” Moving Up, Moving Down, Idle

### âœ… Advantages

âœ… **Eliminates large switch statements**  
âœ… **Clear state transitions** â€” Easy to understand flow  
âœ… **Each state in its own class** â€” Single Responsibility Principle  
âœ… **Easy to add states** â€” Just create new state class  

### âŒ Disadvantages

âŒ **Many classes** â€” One class per state  
âŒ **Complexity** â€” For few states, may be overkill  
âŒ **Context coupling** â€” States need reference to context  

---

## 4. Chain of Responsibility Pattern

### ğŸ¯ Problem
A request needs to be processed by one of several **handlers in a chain**. You don't know which handler should process it, and you want flexibility in adding new handlers.

### âœ… Solution
Creates a chain of handler objects where each handler decides to process or pass the request.

### ğŸ’» Code Example

```typescript
// Handler interface
abstract class SupportHandler {
    protected SupportHandler nextHandler;
    
    public void setNext(SupportHandler handler) {
        this.nextHandler = handler;
    }
    
    public void handle(SupportRequest request) {
        if (canHandle(request)) {
            process(request);
        } else if (nextHandler != null) {
            nextHandler.handle(request);
        } else {
            System.out.println("Request not handled");
        }
    }
    
    protected abstract boolean canHandle(SupportRequest request);
    protected abstract void process(SupportRequest request);
}

// Concrete handlers
class Level1Support extends SupportHandler {
    protected boolean canHandle(SupportRequest request) {
        return request.getPriority() <= 1;
    }
    
    protected void process(SupportRequest request) {
        System.out.println("Level 1 handled: " + request.getIssue());
    }
}

class Level2Support extends SupportHandler {
    protected boolean canHandle(SupportRequest request) {
        return request.getPriority() <= 2;
    }
    
    protected void process(SupportRequest request) {
        System.out.println("Level 2 handled: " + request.getIssue());
    }
}

// Usage
SupportHandler level1 = new Level1Support();
SupportHandler level2 = new Level2Support();
level1.setNext(level2);

SupportRequest request = new SupportRequest("Server down", 2);
level1.handle(request); // Passes to level2
```

### ğŸŒ Real-World Use Cases

- **Logging frameworks** â€” Info logger â†’ Debug logger â†’ Error logger
- **Approval workflows** â€” Manager â†’ Director â†’ VP
- **Servlet filters** â€” Request processing chain
- **Middleware** â€” Express.js, Spring Security interceptors
- **Exception handling** â€” Try-catch chains

### âœ… Advantages

âœ… **Loose coupling** â€” Handlers don't know about each other  
âœ… **Dynamic chains** â€” Build chains at runtime  
âœ… **Easy to add handlers** â€” No code changes needed  

### âŒ Disadvantages

âŒ **Request might not be handled** â€” If chain ends  
âŒ **Difficult debugging** â€” Hard to trace request flow  
âŒ **Performance** â€” Traversing the chain takes time  

---

## 5. Command Pattern

### ğŸ¯ Problem
You need to **decouple the object making a request** from the one executing it. You also want to support undo/redo, queuing, and logging of requests.

### âœ… Solution
Encapsulates a request as an object, allowing you to parameterize with different requests and queue them.

### ğŸ’» Code Example

```typescript
// Command interface
interface Command {
    void execute();
    void undo();
}

// Receiver
class TextEditor {
    private String text = "";
    
    public void write(String content) {
        text += content;
        System.out.println("Text: " + text);
    }
    
    public void delete(int length) {
        if (length <= text.length()) {
            text = text.substring(0, text.length() - length);
        }
        System.out.println("Text: " + text);
    }
}

// Concrete commands
class WriteCommand implements Command {
    private TextEditor editor;
    private String content;
    
    public WriteCommand(TextEditor editor, String content) {
        this.editor = editor;
        this.content = content;
    }
    
    public void execute() {
        editor.write(content);
    }
    
    public void undo() {
        editor.delete(content.length());
    }
}

// Invoker
class CommandHistory {
    private Stack<Command> history = new Stack<>();
    
    public void execute(Command command) {
        command.execute();
        history.push(command);
    }
    
    public void undo() {
        if (!history.isEmpty()) {
            history.pop().undo();
        }
    }
}

// Usage
TextEditor editor = new TextEditor();
CommandHistory history = new CommandHistory();
history.execute(new WriteCommand(editor, "Hello "));
history.execute(new WriteCommand(editor, "World"));
history.undo(); // Remove "World"
```

### ğŸŒ Real-World Use Cases

- **Undo/Redo** â€” Text editors, graphics tools
- **Remote controls** â€” Button commands
- **Job queues** â€” Scheduled tasks
- **Macro recording** â€” Office applications
- **Transaction systems** â€” Commit/rollback

### âœ… Advantages

âœ… **Decouples invoker and receiver**  
âœ… **Undo/Redo support** â€” Easy to implement  
âœ… **Queueing** â€” Queue commands for later  
âœ… **Logging** â€” Audit trail of commands  

### âŒ Disadvantages

âŒ **More classes** â€” One class per command  
âŒ **Overhead** â€” Additional layer of abstraction  
âŒ **Undo complexity** â€” Managing state is tricky  

---

## 6. Interpreter Pattern

### ğŸ¯ Problem
You need to **parse and execute expressions** in a language you define. For example, a calculator evaluating `(2 + 3) * 4`.

### âœ… Solution
Defines a grammar and an interpreter to evaluate sentences in that language.

### ğŸŒ Real-World Use Cases

- **SQL query parsing** â€” Database execution
- **Regular expressions** â€” Pattern matching
- **Mathematical expressions** â€” Calculators
- **Domain-specific languages** â€” Custom notations
- **Template engines** â€” Expression evaluation

---

## 7. Mediator Pattern

### ğŸ¯ Problem
Multiple objects communicate with each other in complex ways. Each object must know about others, creating **tight coupling**.

### âœ… Solution
Defines an object that encapsulates how objects interact and centralizes communication.

### ğŸ’» Code Example

```typescript
// Mediator
interface ChatMediator {
    void sendMessage(String message, User sender);
}

class ChatRoom implements ChatMediator {
    private List<User> users = new ArrayList<>();
    
    public void addUser(User user) {
        users.add(user);
    }
    
    public void sendMessage(String message, User sender) {
        for (User user : users) {
            if (user != sender) {
                user.receive(message);
            }
        }
    }
}

// Colleagues
class User {
    private String name;
    private ChatMediator mediator;
    
    public User(String name, ChatMediator mediator) {
        this.name = name;
        this.mediator = mediator;
    }
    
    public void send(String message) {
        System.out.println(name + " sends: " + message);
        mediator.sendMessage(message, this);
    }
    
    public void receive(String message) {
        System.out.println(name + " receives: " + message);
    }
}
```

### ğŸŒ Real-World Use Cases

- **Chat rooms** â€” Users communicate through chat
- **Dialog boxes** â€” UI elements coordinate
- **Air traffic control** â€” Planes communicate through control tower
- **Game character interactions** â€” Controlled through game manager

---

## 8. Memento Pattern

### ğŸ¯ Problem
You need to **save and restore an object's state** without exposing its internal structure (undo functionality).

### ğŸ’» Code Example

```typescript
// Memento
class EditorMemento {
    private String content;
    
    public EditorMemento(String content) {
        this.content = content;
    }
    
    public String getContent() {
        return content;
    }
}

// Originator
class TextEditor {
    private String content = "";
    
    public void write(String text) {
        content += text;
    }
    
    public EditorMemento save() {
        return new EditorMemento(content);
    }
    
    public void restore(EditorMemento memento) {
        content = memento.getContent();
    }
}

// Caretaker
class EditorHistory {
    private Stack<EditorMemento> history = new Stack<>();
    
    public void save(TextEditor editor) {
        history.push(editor.save());
    }
    
    public void undo(TextEditor editor) {
        if (!history.isEmpty()) {
            editor.restore(history.pop());
        }
    }
}
```

### ğŸŒ Real-World Use Cases

- **Undo/Redo** â€” Saving snapshots
- **Database transactions** â€” Rollback functionality
- **Game saves** â€” Restore game state
- **Version control** â€” Commit history

---

## 9. Template Method Pattern

### ğŸ¯ Problem
Multiple classes have the **same algorithm structure** but differ in details. You want to avoid code duplication.

### ğŸ’» Code Example

```typescript
// Abstract template
abstract class ReportGenerator {
    public final void generate() { // Template method
        gatherData();
        formatData();
        outputReport();
    }
    
    protected abstract void gatherData();
    protected abstract void formatData();
    protected abstract void outputReport();
}

// Concrete implementations
class PDFReport extends ReportGenerator {
    protected void gatherData() { /* ... */ }
    protected void formatData() { /* ... */ }
    protected void outputReport() { System.out.println("PDF generated"); }
}

class HTMLReport extends ReportGenerator {
    protected void gatherData() { /* ... */ }
    protected void formatData() { /* ... */ }
    protected void outputReport() { System.out.println("HTML generated"); }
}
```

### ğŸŒ Real-World Use Cases

- **Game loops** â€” Initialization, update, render
- **Data processing** â€” Read, process, write
- **JUnit TestCase** â€” setUp, test, tearDown

---

## 10. Visitor Pattern

### ğŸ¯ Problem
You need to **perform different operations** on objects in a structure without modifying their classes.

### ğŸŒ Real-World Use Cases

- **Compiler design** â€” Syntax tree traversal
- **Document processing** â€” Different element operations
- **File system** â€” Process files and directories

---

## 11. Iterator Pattern

### ğŸ¯ Problem
You want to access elements of a collection **without exposing its structure**.

---

## Comparison Table: Behavioral Patterns

| Pattern | Use When | Complexity | Key Benefit |
|---------|----------|-----------|------------|
| **Observer** | Need notifications | Medium | Loose coupling |
| **Strategy** | Multiple algorithms | Medium | Runtime switching |
| **State** | Complex state logic | Medium | Clear state transitions |
| **Chain of Responsibility** | Dynamic handlers | Medium | Flexible chain building |
| **Command** | Undo/Redo needed | Medium | Request encapsulation |
| **Interpreter** | Parse expressions | High | Language interpretation |
| **Mediator** | Complex communication | High | Centralized control |
| **Memento** | Save/restore state | Medium | Encapsulated snapshots |
| **Template Method** | Code reuse needed | Low | Algorithm structure |
| **Visitor** | Multiple operations | High | Separate operations |

---

## Learning Checklist

- [ ] Implement Observer pattern with real event system
- [ ] Use Strategy pattern to replace if-else chains
- [ ] Build state machine with State pattern
- [ ] Create command handler with undo functionality
- [ ] Understand Mediator vs Observer differences
- [ ] Practice combining patterns in a workflow

