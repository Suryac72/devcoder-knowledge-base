---
title: Creational Patterns
description: Object creation patterns
order: 1
---

import { Callout } from 'fumadocs-ui/components/callout';

<Callout type="info">
This page follows **Gang of Four (GoF)** design patterns with real-world examples.
</Callout>

# Creational Patterns

Creational patterns deal with **object creation mechanisms**, trying to create objects in a manner suitable to the situation. Instead of directly instantiating classes, they provide flexible and reusable ways to build objects.

**When to use:** When object creation logic is complex, when you need flexibility in how objects are built, or when you want to control the instantiation process.

---

## 1. Singleton Pattern

### ğŸ¯ Problem
You need exactly **one instance** of a class throughout your application, and you want a global access point to that instance. Multiple instances would cause problems (like duplicate database connections or configuration conflicts).

### âœ… Solution
The Singleton Pattern ensures that a class has only one instance and provides a global point of access to it.

### ğŸ”‘ Key Concepts

- **Private Constructor**: Prevents instantiation from outside the class
- **Static Instance**: Holds the single instance of the class
- **Static Access Method**: Provides global access (usually `getInstance()`)
- **Thread Safety**: Ensures only one instance even in multithreaded environments

### ğŸ’» Implementation Types

| Type | When Created | Thread Safe | Use Case |
|------|--------------|-------------|----------|
| **Eager** | Class load time | âœ… Yes | Simple, always needed |
| **Lazy** | First access | âŒ No | Memory optimization |
| **Bill Pugh** | First access | âœ… Yes | Best approach |
| **Double-Checked** | First access | âœ… Yes | Performance optimized |

### ğŸ’¡ Code Example

```typescript
// Bill Pugh Singleton (Most recommended)
public class DatabaseConnection {
    private DatabaseConnection() {}
    
    private static class SingletonHolder {
        static final DatabaseConnection INSTANCE = new DatabaseConnection();
    }
    
    public static DatabaseConnection getInstance() {
        return SingletonHolder.INSTANCE;
    }
}

// Usage
DatabaseConnection db = DatabaseConnection.getInstance();
```

### ğŸŒ Real-World Use Cases

- **Database connections** â€” Single connection pool for entire app
- **Logging frameworks** â€” Logger instances (Log4j, SLF4J)
- **Configuration managers** â€” Single configuration object
- **Thread pools** â€” Executor service
- **Caches** â€” In-memory cache instance
- **Spring ApplicationContext** â€” IoC container

### âœ… Advantages

âœ… **Memory efficient** â€” Only one instance consumes memory  
âœ… **Global access** â€” Easy to access from anywhere  
âœ… **Lazy loading** â€” Can defer object creation  
âœ… **Thread-safe options** â€” Multiple implementation approaches  

### âŒ Disadvantages

âŒ **Hard to test** â€” Global state is difficult to mock  
âŒ **Hidden dependencies** â€” Makes code harder to understand  
âŒ **Not thread-safe** â€” All implementations aren't thread-safe  
âŒ **Violates SRP** â€” Mixing singleton logic with business logic  

### âš ï¸ Common Pitfalls

- Reflection can break the singleton pattern
- Serialization creates new instances on deserialization
- Cloning breaks singleton behavior
- Not implementing thread safety properly

---

## 2. Factory Pattern

### ğŸ¯ Problem
You have multiple classes that implement the same interface, and you want to create instances without knowing the concrete classes. Hardcoding `new ConcreteClass()` throughout your code makes it inflexible.

### âœ… Solution
The Factory Pattern provides an interface for creating objects, but lets subclasses decide which class to instantiate.

### ğŸ”‘ Key Concepts

- **Creator Interface**: Declares factory method
- **Concrete Creator**: Implements factory method to create specific products
- **Product Interface**: Common interface for all created objects
- **Concrete Product**: Actual implementations

### ğŸ’» Code Example

```typescript
// Product interface
interface Database {
    void connect();
}

// Concrete products
class MySQLDatabase implements Database {
    public void connect() { System.out.println("MySQL connected"); }
}

class PostgreSQLDatabase implements Database {
    public void connect() { System.out.println("PostgreSQL connected"); }
}

// Factory
abstract class DatabaseFactory {
    abstract Database createDatabase();
    
    void setupDatabase() {
        Database db = createDatabase();
        db.connect();
    }
}

class MySQLFactory extends DatabaseFactory {
    @Override
    Database createDatabase() {
        return new MySQLDatabase();
    }
}

// Usage
DatabaseFactory factory = new MySQLFactory();
factory.setupDatabase();
```

### ğŸŒ Real-World Use Cases

- **Database drivers** â€” MySQL, PostgreSQL, Oracle connections
- **UI components** â€” Creating buttons, text fields for different platforms
- **Payment processors** â€” PayPal, Stripe, Square
- **Loggers** â€” FileLogger, ConsoleLogger, DatabaseLogger
- **File parsers** â€” JSON, XML, CSV parsers

### âœ… Advantages

âœ… **Loose coupling** â€” Client doesn't depend on concrete classes  
âœ… **Flexible** â€” Easy to add new product types  
âœ… **Centralized** â€” Creation logic in one place  
âœ… **Follows SOLID** â€” Open/Closed Principle  

### âŒ Disadvantages

âŒ **More classes** â€” Increases codebase complexity  
âŒ **Overhead** â€” Can be overkill for simple cases  
âŒ **Less transparent** â€” Harder to trace which class is created  

---

## 3. Abstract Factory Pattern

### ğŸ¯ Problem
You need to create **families of related objects** that work together. For example, a Windows UI theme needs Windows buttons, Windows checkboxes, and Windows windows â€” all coordinated.

### âœ… Solution
The Abstract Factory Pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.

### ğŸ”‘ Key Concepts

- **Abstract Factory**: Declares methods for creating related products
- **Concrete Factory**: Implements each method to create specific product family
- **Product Family**: Multiple related interfaces (e.g., Button, Checkbox)
- **Concrete Products**: Implementations for each theme/variant

### ğŸ’» Code Example

```typescript
// Abstract products
interface Button { void paint(); }
interface Checkbox { void paint(); }

// Windows family
class WindowsButton implements Button {
    public void paint() { System.out.println("Windows button"); }
}
class WindowsCheckbox implements Checkbox {
    public void paint() { System.out.println("Windows checkbox"); }
}

// Mac family
class MacButton implements Button {
    public void paint() { System.out.println("Mac button"); }
}
class MacCheckbox implements Checkbox {
    public void paint() { System.out.println("Mac checkbox"); }
}

// Abstract factory
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Concrete factories
class WindowsFactory implements GUIFactory {
    public Button createButton() { return new WindowsButton(); }
    public Checkbox createCheckbox() { return new WindowsCheckbox(); }
}

class MacFactory implements GUIFactory {
    public Button createButton() { return new MacButton(); }
    public Checkbox createCheckbox() { return new MacCheckbox(); }
}
```

### ğŸŒ Real-World Use Cases

- **UI frameworks** â€” Different themes (Windows, Mac, Linux)
- **Report generators** â€” PDF, HTML, Excel factories
- **Database abstractions** â€” Different dialects per database

### âœ… Advantages

âœ… **Ensures consistency** â€” Related objects work well together  
âœ… **Easy switching** â€” Change entire family with one line  
âœ… **Encapsulation** â€” Hide product family details  

### âŒ Disadvantages

âŒ **More complex** â€” Harder to understand than Factory Pattern  
âŒ **Adding products** â€” Requires changes to all factories  
âŒ **Overkill** â€” Can be over-engineering for simple cases  

---

## 4. Builder Pattern

### ğŸ¯ Problem
You need to create complex objects with many optional parameters. Using constructors with many parameters becomes unreadable and error-prone (constructor telescoping).

```typescript
// âŒ Bad: Constructor telescoping
new Pizza(dough, sauce, cheese, pepperoni, mushrooms, olives, corn);
```

### âœ… Solution
The Builder Pattern provides a way to construct complex objects **step by step** using a fluent interface.

### ğŸ”‘ Key Concepts

- **Builder**: Constructs the product step-by-step
- **Director** (optional): Defines construction algorithm
- **Product**: Complex object being built
- **Fluent Interface**: Method chaining for readability

### ğŸ’» Code Example

```typescript
public class Pizza {
    private String dough;
    private String sauce;
    private boolean cheese;
    private boolean pepperoni;
    private boolean mushrooms;
    
    private Pizza(Builder builder) {
        this.dough = builder.dough;
        this.sauce = builder.sauce;
        this.cheese = builder.cheese;
        this.pepperoni = builder.pepperoni;
        this.mushrooms = builder.mushrooms;
    }
    
    public static class Builder {
        private String dough = "thin";
        private String sauce = "tomato";
        private boolean cheese = true;
        private boolean pepperoni = false;
        private boolean mushrooms = false;
        
        public Builder dough(String dough) {
            this.dough = dough;
            return this;
        }
        
        public Builder pepperoni() {
            this.pepperoni = true;
            return this;
        }
        
        public Pizza build() {
            return new Pizza(this);
        }
    }
}

// âœ… Usage: Clear and readable
Pizza pizza = new Pizza.Builder()
    .dough("thick")
    .pepperoni()
    .mushrooms()
    .build();
```

### ğŸŒ Real-World Use Cases

- **Complex configurations** â€” StringBuilder, HttpRequest builders
- **Database query builders** â€” SQL builders
- **UI construction** â€” HTML/XML builders
- **Immutable objects** â€” Safe object creation

### âœ… Advantages

âœ… **Readable** â€” Self-documenting with fluent interface  
âœ… **Flexible** â€” Optional parameters handled elegantly  
âœ… **Immutable objects** â€” Can create thread-safe objects  
âœ… **Fewer constructors** â€” Cleaner class design  

### âŒ Disadvantages

âŒ **More code** â€” Need builder + product classes  
âŒ **Overhead** â€” Performance cost vs simple constructor  
âŒ **Not always necessary** â€” Overkill for simple objects  

---

## 5. Prototype Pattern

### ğŸ¯ Problem
Creating new objects from scratch is **expensive** (database queries, file I/O, calculations). You'd rather copy an existing object and modify it.

### âœ… Solution
The Prototype Pattern creates new objects by **copying an existing object** (prototype) rather than creating from scratch.

### ğŸ”‘ Key Concepts

- **Prototype**: Original object that can be cloned
- **Shallow Copy**: Copies references to objects (not the objects themselves)
- **Deep Copy**: Copies everything, including nested objects
- **Clone Registry**: Keeps available prototypes for reuse

### ğŸ’» Code Example

```typescript
public class User implements Cloneable {
    private String name;
    private String email;
    private List<String> roles;
    
    // Shallow copy
    @Override
    public User clone() throws CloneNotSupportedException {
        return (User) super.clone();
    }
    
    // Deep copy
    public User deepClone() throws CloneNotSupportedException {
        User cloned = (User) super.clone();
        cloned.roles = new ArrayList<>(this.roles);
        return cloned;
    }
}

// Usage
User admin = new User("Admin", "admin@example.com");
admin.addRole("ADMIN");

User copy = admin.deepClone();
copy.setName("User2");
// admin and copy are independent
```

### ğŸŒ Real-World Use Cases

- **Game development** â€” Cloning game objects, NPCs
- **Undo/Redo** â€” Saving state snapshots
- **Database records** â€” Duplicating records with modifications
- **UI components** â€” Copying widgets with different properties

### âœ… Advantages

âœ… **Performance** â€” Copying faster than creating from scratch  
âœ… **Flexibility** â€” Avoid subclassing for variations  
âœ… **State snapshots** â€” Save object state for undo functionality  

### âŒ Disadvantages

âŒ **Shallow vs Deep** â€” Confusion between copy types  
âŒ **Circular references** â€” Can cause infinite loops  
âŒ **Complexity** â€” Not obvious which objects are cloned  

---

## Comparison Table: Creational Patterns

| Pattern | Use When | Complexity | Key Benefit |
|---------|----------|-----------|------------|
| **Singleton** | Need single instance | Low | Memory efficient |
| **Factory** | Multiple object types | Medium | Flexible creation |
| **Abstract Factory** | Related object families | High | Ensures consistency |
| **Builder** | Complex objects | Medium | Readable construction |
| **Prototype** | Expensive creation | Medium | Performance gain |

---

## Learning Checklist

- [ ] Understand why Singleton is needed in applications
- [ ] Know when to use Factory vs Abstract Factory
- [ ] Build complex objects using Builder pattern
- [ ] Implement deep and shallow cloning
- [ ] Practice combining patterns in a project

