---
title: Structural Patterns
description: Object composition patterns
order: 3
---

import { Callout } from 'fumadocs-ui/components/callout';

<Callout type="info">
This page follows **Gang of Four (GoF)** design patterns with real-world examples.
</Callout>

# Structural Patterns

Structural patterns deal with **object composition** and relationships. They help compose objects into larger structures while maintaining flexibility and efficiency.

**When to use:** When you need to organize objects, add responsibilities, simplify complex systems, or make incompatible things work together.

---

## 1. Adapter Pattern

### ğŸ¯ Problem
You have two **incompatible interfaces** that need to work together. For example, you have an old library expecting `LegacyPaymentProcessor` but your new code uses `ModernPaymentGateway`. Without an adapter, they can't communicate.

### âœ… Solution
The Adapter Pattern converts one interface into another that clients expect, allowing incompatible interfaces to work together.

### ğŸ”‘ Key Concepts

- **Target**: The interface that clients expect
- **Adapter**: The converter between incompatible interfaces
- **Adaptee**: The class with the incompatible interface
- **Client**: Uses the target interface

### ğŸ’» Code Example

```typescript
// Existing interface (Adaptee)
class LegacyPaymentProcessor {
    public boolean processPayment(double amount) {
        System.out.println("Legacy payment: " + amount);
        return true;
    }
}

// Modern interface expected by new code (Target)
interface PaymentGateway {
    void pay(double amount);
}

// Adapter
class PaymentAdapter implements PaymentGateway {
    private LegacyPaymentProcessor legacy;
    
    public PaymentAdapter(LegacyPaymentProcessor legacy) {
        this.legacy = legacy;
    }
    
    @Override
    public void pay(double amount) {
        if (legacy.processPayment(amount)) {
            System.out.println("Payment successful");
        }
    }
}

// Usage
LegacyPaymentProcessor old = new LegacyPaymentProcessor();
PaymentGateway gateway = new PaymentAdapter(old);
gateway.pay(100); // Old system works with new interface
```

### ğŸŒ Real-World Use Cases

- **Power adapters** â€” Convert voltage standards
- **Database drivers** â€” JDBC adapters for different databases
- **Framework wrappers** â€” Making legacy APIs work with new code
- **Payment integrations** â€” Different payment providers
- **Audio/video converters** â€” HDMI to VGA adapters

### âœ… Advantages

âœ… **Bridge incompatible interfaces** â€” Makes old and new code work  
âœ… **Reuse existing code** â€” Don't rewrite working classes  
âœ… **Single Responsibility** â€” Separation of concerns  
âœ… **Open/Closed Principle** â€” Extend without modifying existing code  

### âŒ Disadvantages

âŒ **Additional class** â€” More complexity  
âŒ **Can hide design issues** â€” May indicate poor design  
âŒ **Debugging difficulty** â€” Extra layer of abstraction  

---

## 2. Bridge Pattern

### ğŸ¯ Problem
You have a hierarchy that would **explode with combinations**. For example:
- Shape hierarchy: Circle, Square, Triangle
- Color variants: Red, Green, Blue
- This creates 3 Ã— 3 = 9 classes!

Instead of extending both shape and color, bridge them separately.

### âœ… Solution
Decouples an abstraction from its implementation so they can vary independently.

### ğŸ”‘ Key Concepts

- **Abstraction**: High-level interface (e.g., Shape)
- **Refined Abstraction**: Extended abstraction (e.g., Circle)
- **Implementor**: Implementation interface (e.g., Color)
- **Concrete Implementor**: Actual implementation (e.g., RedColor)

### ğŸ’» Code Example

```typescript
// Implementor (separate from shape)
interface Color {
    String getColor();
}

class RedColor implements Color {
    public String getColor() { return "Red"; }
}

class BlueColor implements Color {
    public String getColor() { return "Blue"; }
}

// Abstraction uses implementor (Bridge)
abstract class Shape {
    protected Color color;
    
    public Shape(Color color) {
        this.color = color;
    }
    
    abstract void draw();
}

// Refined abstractions
class Circle extends Shape {
    public Circle(Color color) {
        super(color);
    }
    
    @Override
    void draw() {
        System.out.println("Circle in " + color.getColor());
    }
}

class Square extends Shape {
    public Square(Color color) {
        super(color);
    }
    
    @Override
    void draw() {
        System.out.println("Square in " + color.getColor());
    }
}

// Usage: Create any combination without 9 classes!
Shape redCircle = new Circle(new RedColor());
redCircle.draw(); // Circle in Red

Shape blueSquare = new Square(new BlueColor());
blueSquare.draw(); // Square in Blue
```

### ğŸŒ Real-World Use Cases

- **Cross-platform apps** â€” Windows/Mac implementations
- **Database abstraction** â€” Different SQL dialects
- **Graphics libraries** â€” Different rendering backends
- **Communication channels** â€” TCP, UDP implementations

### âœ… Advantages

âœ… **Avoids class explosion** â€” Avoid 2D inheritance hierarchies  
âœ… **Independent variation** â€” Abstraction and implementation separate  
âœ… **Better encapsulation** â€” Hide implementation details  

### âŒ Disadvantages

âŒ **More complex** â€” Harder to understand  
âŒ **Overhead** â€” Extra indirection for simple cases  

---

## 3. Composite Pattern

### ğŸ¯ Problem
You have a **tree structure** (like a file system) where folders contain files and other folders. You want to treat individual files and folders **uniformly** without checking "is this a file or folder?".

### âœ… Solution
Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly.

### ğŸ”‘ Key Concepts

- **Component**: Common interface for leaves and composites
- **Leaf**: Represents individual objects (files)
- **Composite**: Container that can hold other components (folders)
- **Recursive**: Composites can contain composites

### ğŸ’» Code Example

```typescript
// Component interface
interface FileSystemComponent {
    void display(int depth);
}

// Leaf
class File implements FileSystemComponent {
    private String name;
    
    public File(String name) {
        this.name = name;
    }
    
    @Override
    public void display(int depth) {
        System.out.println("  ".repeat(depth) + "ğŸ“„ " + name);
    }
}

// Composite
class Folder implements FileSystemComponent {
    private String name;
    private List<FileSystemComponent> contents = new ArrayList<>();
    
    public Folder(String name) {
        this.name = name;
    }
    
    public void add(FileSystemComponent component) {
        contents.add(component);
    }
    
    @Override
    public void display(int depth) {
        System.out.println("  ".repeat(depth) + "ğŸ“ " + name);
        for (FileSystemComponent component : contents) {
            component.display(depth + 1);
        }
    }
}

// Usage: Treat both uniformly
Folder root = new Folder("root");
root.add(new File("readme.txt"));

Folder docs = new Folder("Documents");
docs.add(new File("resume.pdf"));
root.add(docs);

root.display(0); // Shows tree structure
```

### ğŸŒ Real-World Use Cases

- **File systems** â€” Folders and files
- **GUI frameworks** â€” Panels, buttons, text fields
- **Organization charts** â€” Departments and employees
- **Menu systems** â€” Menus with submenus

### âœ… Advantages

âœ… **Uniform treatment** â€” Same interface for parts and wholes  
âœ… **Simple code** â€” Clients don't check object type  
âœ… **Easy trees** â€” Build hierarchies naturally  
âœ… **Flexible** â€” Add new component types easily  

### âŒ Disadvantages

âŒ **Type checking** â€” Can't easily restrict children types  
âŒ **Overhead** â€” Performance cost for simple objects  
âŒ **Design limitations** â€” Less control over structure  

---

## 4. Decorator Pattern

### ğŸ¯ Problem
You need to **add features to objects dynamically**. For example, a coffee cup can have different additions: sugar, milk, caramel, chocolate. Using inheritance creates an explosion of classes:

```
Coffee â†’ CoffeeWithSugar â†’ CoffeeWithSugarAndMilk â†’ ...
```

### âœ… Solution
Attaches additional responsibilities to an object dynamically, providing a flexible alternative to subclassing.

### ğŸ”‘ Key Concepts

- **Component**: Original interface
- **Concrete Component**: The object being decorated
- **Decorator**: Base decorator implementing component interface
- **Concrete Decorator**: Adds specific functionality
- **Wrapping**: Decorator wraps the component

### ğŸ’» Code Example

```typescript
// Component interface
interface Coffee {
    double getCost();
    String getDescription();
}

// Concrete component
class BasicCoffee implements Coffee {
    @Override
    public double getCost() { return 2.0; }
    
    @Override
    public String getDescription() { return "Basic Coffee"; }
}

// Decorator base class
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

// Concrete decorators
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public double getCost() { return coffee.getCost() + 0.5; }
    
    @Override
    public String getDescription() { return coffee.getDescription() + ", Milk"; }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public double getCost() { return coffee.getCost() + 0.2; }
    
    @Override
    public String getDescription() { return coffee.getDescription() + ", Sugar"; }
}

// Usage: Stack decorators for any combination
Coffee coffee = new BasicCoffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);

System.out.println(coffee.getDescription()); // Basic Coffee, Milk, Sugar
System.out.println(coffee.getCost()); // 2.7
```

### ğŸŒ Real-World Use Cases

- **Java IO streams** â€” FileInputStream wrapped with BufferedInputStream
- **Text formatting** â€” Bold, italic, underline
- **Feature toggles** â€” Add logging, caching, authorization
- **UI enhancements** â€” Borders, scrollbars, titles on components

### âœ… Advantages

âœ… **Flexible** â€” Add features at runtime  
âœ… **No subclass explosion** â€” Avoid creating many classes  
âœ… **Single Responsibility** â€” Each decorator has one job  
âœ… **Stackable** â€” Combine multiple decorators  

### âŒ Disadvantages

âŒ **Many objects** â€” Each wrapper adds an object  
âŒ **Order matters** â€” Decorator order can affect results  
âŒ **Debugging** â€” Hard to trace with many layers  

---

## 5. Facade Pattern

### ğŸ¯ Problem
Your client code needs to interact with a **complex subsystem** with many interdependent classes. This creates tight coupling and difficult code.

### âœ… Solution
Provides a unified, simplified interface to a complex subsystem.

### ğŸ’» Code Example

```typescript
// Complex subsystem classes
class Lights {
    public void on() { System.out.println("Lights on"); }
    public void off() { System.out.println("Lights off"); }
}

class Temperature {
    public void warm() { System.out.println("Temperature warming"); }
}

class Entertainment {
    public void startMovie() { System.out.println("Movie started"); }
}

// Facade: Simplifies interaction
class HomeAutomation {
    private Lights lights;
    private Temperature temperature;
    private Entertainment entertainment;
    
    public HomeAutomation() {
        this.lights = new Lights();
        this.temperature = new Temperature();
        this.entertainment = new Entertainment();
    }
    
    // Simple methods that hide complexity
    public void movieTime() {
        lights.off();
        temperature.warm();
        entertainment.startMovie();
    }
    
    public void leavingHome() {
        lights.off();
    }
}

// Usage: Simple and clean
HomeAutomation home = new HomeAutomation();
home.movieTime(); // Does all setup automatically
```

### ğŸŒ Real-World Use Cases

- **Database frameworks** â€” Hibernate hiding SQL complexity
- **API wrappers** â€” Simplifying complex APIs
- **Logging frameworks** â€” SLF4J facade for multiple loggers
- **Spring Data** â€” Simplifying database operations
- **Home automation** â€” Single interface for multiple systems

### âœ… Advantages

âœ… **Simplifies complex systems** â€” Hide internal complexity  
âœ… **Decouples clients** â€” Don't depend on subsystem classes  
âœ… **Easier to maintain** â€” Central control point  

### âŒ Disadvantages

âŒ **God Object** â€” Facade can become too large  
âŒ **Hidden features** â€” Advanced users can't access subsystem directly  
âŒ **Additional layer** â€” Slight performance overhead  

---

## 6. Flyweight Pattern

### ğŸ¯ Problem
You need to create **millions of similar small objects** (like characters in a text editor, particles in a game, or tiles in a map). Memory usage becomes prohibitive.

### âœ… Solution
Uses sharing to support large numbers of objects efficiently by sharing common state.

### ğŸ”‘ Key Concepts

- **Intrinsic State**: Shared, immutable data (font, color)
- **Extrinsic State**: Unique per object (position, specific text)
- **Flyweight Factory**: Creates and caches flyweights
- **Object Pooling**: Reuse objects instead of creating new ones

### ğŸ’» Code Example

```typescript
// Flyweight
class Character {
    private char symbol;
    private String font;
    
    public Character(char symbol, String font) {
        this.symbol = symbol;
        this.font = font;
    }
    
    public void display(int row, int col) {
        System.out.println("'" + symbol + "' at (" + row + "," + col + ") in " + font);
    }
}

// Flyweight Factory
class CharacterFactory {
    private static Map<String, Character> cache = new HashMap<>();
    
    public static Character getCharacter(char symbol, String font) {
        String key = symbol + "-" + font;
        
        if (!cache.containsKey(key)) {
            cache.put(key, new Character(symbol, font));
        }
        
        return cache.get(key);
    }
}

// Usage: Reuse same character object
Character a1 = CharacterFactory.getCharacter('A', "Arial");
Character a2 = CharacterFactory.getCharacter('A', "Arial");
System.out.println(a1 == a2); // true - same object!

a1.display(0, 0);
a2.display(0, 1);
```

### ğŸŒ Real-World Use Cases

- **Text editors** â€” Sharing character objects
- **Game particle systems** â€” Reusing particle objects
- **String interning** â€” Java's String pool
- **Connection pooling** â€” Database connections

### âœ… Advantages

âœ… **Memory savings** â€” Massive reduction with millions of objects  
âœ… **Performance** â€” Fewer objects to manage  
âœ… **Centralization** â€” Shared state in one place  

### âŒ Disadvantages

âŒ **Complexity** â€” Intrinsic vs extrinsic state confusion  
âŒ **Thread safety** â€” Shared objects must be thread-safe  
âŒ **Debugging** â€” Hidden object reuse makes debugging harder  

---

## 7. Proxy Pattern

### ğŸ¯ Problem
You want to **control access** to another object, provide a **placeholder** until the object is needed, or **log/monitor** access.

### âœ… Solution
Provides a surrogate or placeholder that controls access to the real object.

### ğŸ”‘ Key Concepts

- **Subject**: Common interface
- **Real Subject**: Actual object
- **Proxy**: Controls access to real subject
- **Types**:
  - **Protection Proxy** â€” Access control
  - **Virtual Proxy** â€” Lazy initialization
  - **Cache Proxy** â€” Caching results
  - **Remote Proxy** â€” Represents distant object

### ğŸ’» Code Example

```typescript
// Subject interface
interface DataService {
    String fetchData(String id);
}

// Real subject - expensive operation
class RealDataService implements DataService {
    @Override
    public String fetchData(String id) {
        System.out.println("Fetching from database: " + id);
        // Simulate expensive operation
        return "Data for " + id;
    }
}

// Proxy with caching
class CachedDataServiceProxy implements DataService {
    private RealDataService realService = new RealDataService();
    private Map<String, String> cache = new HashMap<>();
    
    @Override
    public String fetchData(String id) {
        if (cache.containsKey(id)) {
            System.out.println("Returning from cache: " + id);
            return cache.get(id);
        }
        
        String data = realService.fetchData(id);
        cache.put(id, data);
        return data;
    }
}

// Usage
DataService service = new CachedDataServiceProxy();
service.fetchData("user1"); // Fetches and caches
service.fetchData("user1"); // Returns from cache
```

### ğŸŒ Real-World Use Cases

- **Lazy loading** â€” Load heavy objects only when needed
- **Access control** â€” Check permissions before allowing access
- **Logging** â€” Track all access to sensitive objects
- **Remote objects** â€” Network calls to distant services
- **Caching** â€” Cache expensive operations

### âœ… Advantages

âœ… **Controls access** â€” Restrict operations on real object  
âœ… **Lazy initialization** â€” Defer expensive creation  
âœ… **Caching** â€” Improve performance  
âœ… **Logging/Monitoring** â€” Track access  

### âŒ Disadvantages

âŒ **Additional object** â€” More memory usage  
âŒ **Performance** â€” Extra layer slows access  
âŒ **Complexity** â€” More code to maintain  

---

## Comparison Table: Structural Patterns

| Pattern | Use When | Complexity | Key Benefit |
|---------|----------|-----------|------------|
| **Adapter** | Incompatible interfaces | Low | Bridge incompatible APIs |
| **Bridge** | Avoiding class explosion | Medium | Independent variations |
| **Composite** | Tree structures | Medium | Uniform treatment |
| **Decorator** | Dynamic features | Medium | Flexible feature addition |
| **Facade** | Complex subsystems | Low | Simplified interface |
| **Flyweight** | Millions of objects | High | Memory efficiency |
| **Proxy** | Controlled access | Medium | Access control |

---

## Learning Checklist

- [ ] Use Adapter to integrate incompatible libraries
- [ ] Apply Bridge to separate abstraction from implementation
- [ ] Build tree structures with Composite
- [ ] Stack Decorators for dynamic behavior
- [ ] Simplify complex systems with Facade
- [ ] Implement Flyweight for memory efficiency
- [ ] Control access with Proxy pattern

